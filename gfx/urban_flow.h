/* Generated with shader-compressor by NR4/Team210. */
#ifndef URBAN_FLOW_H
#define URBAN_FLOW_H
const char * urban_flow_frag =
"/* Pajazzo Urban Flow Visuals\n"
"* Copyright (C) 2019  Alexander Kraus <nr4@z10.info>\n"
"* \n"
"* This program is free software: you can redistribute it and/or modify\n"
"* it under the terms of the GNU General Public License as published by\n"
"* the Free Software Foundation, either version 3 of the License, or\n"
"* (at your option) any later version.\n"
"* \n"
"* This program is distributed in the hope that it will be useful,\n"
"* but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"* GNU General Public License for more details.\n"
"* \n"
"* You should have received a copy of the GNU General Public License\n"
"* along with this program.  If not, see <http://www.gnu.org/licenses/>.\n"
"*/\n"
"#version 130\n"
"\n"
"uniform float iTime;\n"
"uniform vec2 iResolution;\n"
"\n"
"// Global constants\n"
"const float pi = acos(-1.);\n"
"const vec3 c = vec3(1.0, 0.0, -1.0);\n"
"float a = 1.0;\n"
"vec2 offset = c.yy,\n"
"    size = vec2(.1,.05),\n"
"    per_stone_offset = .01*c.xx;\n"
"\n"
"// Hash function\n"
"void rand(in vec2 x, out float num)\n"
"{\n"
"    x += 400.;\n"
"    num = fract(sin(dot(sign(x)*abs(x) ,vec2(12.9898,78.233)))*43758.5453);\n"
"}\n"
"\n"
"// Arbitrary-frequency 2D noise\n"
"void lfnoise(in vec2 t, out float num)\n"
"{\n"
"    vec2 i = floor(t);\n"
"    t = fract(t);\n"
"    //t = ((6.*t-15.)*t+10.)*t*t*t;  // TODO: add this for slower perlin noise\n"
"    t = smoothstep(c.yy, c.xx, t); // TODO: add this for faster value noise\n"
"    vec2 v1, v2;\n"
"    rand(i, v1.x);\n"
"    rand(i+c.xy, v1.y);\n"
"    rand(i+c.yx, v2.x);\n"
"    rand(i+c.xx, v2.y);\n"
"    v1 = c.zz+2.*mix(v1, v2, t.y);\n"
"    num = mix(v1.x, v1.y, t.x);\n"
"}\n"
"\n"
"// Multi-frequency 2D noise\n"
"void mfnoise(in vec2 x, in float fmin, in float fmax, in float alpha, out float num)\n"
"{\n"
"    num = 0.;\n"
"    float a = 1., nf = 0., buf;\n"
"    for(float f = fmin; f<fmax; f = f*2.)\n"
"    {\n"
"        lfnoise(f*x, buf);\n"
"        num += a*buf;\n"
"        a *= alpha;\n"
"        nf += 1.;\n"
"    }\n"
"    num *= (1.-alpha)/(1.-pow(alpha, nf));\n"
"}\n"
"\n"
"void rot(in vec3 p, out mat3 rot)\n"
"{\n"
"    rot = mat3(c.xyyy, cos(p.x), sin(p.x), 0., -sin(p.x), cos(p.x))\n"
"        *mat3(cos(p.y), 0., -sin(p.y), c.yxy, sin(p.y), 0., cos(p.y))\n"
"        *mat3(cos(p.z), -sin(p.z), 0., sin(p.z), cos(p.z), c.yyyx);\n"
"}\n"
"\n"
"// 2D box\n"
"void dbox(in vec2 p, in vec2 b, out float dst)\n"
"{\n"
"    vec2 d = abs(p) - b;\n"
"    dst = length(max(d,0.0)) + min(max(d.x,d.y),0.0); \n"
"}\n"
"\n"
"// 2D circle\n"
"void dcircle(in vec2 x, in float r, out float dst)\n"
"{\n"
"    dst = length(x)-r;\n"
"}\n"
"\n"
"// Stroke\n"
"void stroke(in float d0, in float s, out float d)\n"
"{\n"
"    d = abs(d0)-s;\n"
"}\n"
"\n"
"// Extrusion\n"
"void zextrude(in float z, in float d2d, in float h, out float d)\n"
"{\n"
"    vec2 w = vec2(-d2d, abs(z)-0.5*h);\n"
"    d = length(max(w,0.0));\n"
"}\n"
"\n"
"// Add sdfs to scene\n"
"void add(in vec4 old, in vec4 new, out vec4 result)\n"
"{\n"
"    result = mix(old, new, step(new.x,0.));\n"
"}\n"
"\n"
"// Mix appropriate marble colors.\n"
"void color(in float scale, out vec3 col)\n"
"{\n"
"    const int N = 13;\n"
"    const vec3 colors[N] = vec3[N](\n"
"        c.yyy,\n"
"        vec3(0.15,0.14,0.12),\n"
"        vec3(0.38,0.16,0.16),\n"
"        vec3(0.42,0.20,0.19),\n"
"        vec3(0.60,0.14,0.16),\n"
"        vec3(0.70,0.11,0.15),\n"
"        vec3(0.89,0.11,0.10),\n"
"        vec3(0.89,0.27,0.03),\n"
"        vec3(0.92,0.39,0.14),\n"
"        vec3(0.91,0.47,0.15),\n"
"        vec3(0.92,0.57,0.14),\n"
"        vec3(0.90,0.63,0.12),\n"
"        vec3(0.92,0.72,0.14)\n"
"    );\n"
"    float index = floor(scale*float(N)), \n"
"        remainder = scale*float(N)-index;\n"
"    col = mix(colors[int(index)],colors[int(index)+1], remainder);\n"
"}\n"
"\n"
"// Distance to regular voronoi\n"
"void dvoronoi(in vec2 x, out float d, out vec2 ind)\n"
"{\n"
"    vec2 y = floor(x);\n"
"    float ret = 1.;\n"
"    \n"
"    //find closest control point. (\"In which cell am I?\")\n"
"    vec2 pf=c.yy, p;\n"
"    float df=10.;\n"
"    \n"
"    for(int i=-1; i<=1; i+=1)\n"
"        for(int j=-1; j<=1; j+=1)\n"
"        {\n"
"            p = y + vec2(float(i), float(j));\n"
"            float pa;\n"
"            rand(p, pa);\n"
"            p += pa;\n"
"            \n"
"            d = length(x-p);\n"
"            \n"
"            if(d < df)\n"
"            {\n"
"                df = d;\n"
"                pf = p;\n"
"            }\n"
"        }\n"
"    \n"
"    //compute voronoi distance: minimum distance to any edge\n"
"    for(int i=-1; i<=1; i+=1)\n"
"        for(int j=-1; j<=1; j+=1)\n"
"        {\n"
"            p = y + vec2(float(i), float(j));\n"
"            float pa;\n"
"            rand(p, pa);\n"
"            p += pa;\n"
"            \n"
"            vec2 o = p - pf;\n"
"            d = length(.5*o-dot(x-pf, o)/dot(o,o)*o);\n"
"            ret = min(ret, d);\n"
"        }\n"
"    \n"
"    d = ret;\n"
"    ind = pf;\n"
"}\n"
"\n"
"void scene(in vec3 x, out vec2 d)\n"
"{\n"
"    vec3 y = vec3(mod(offset + x.xy, 2.*size-per_stone_offset)\n"
"                -size-.5*per_stone_offset, x.z);\n"
"    vec2 ind = (x-y).xy/(2.*size-per_stone_offset);\n"
"    float dv;\n"
"    vec2 vi;\n"
"    dvoronoi(x.xy/size*.5, dv, vi);\n"
"    ind = mix(ind, vi, clamp((iTime-70.)/5., 0., 1.));\n"
"    float ra;\n"
"    lfnoise(ind-iTime, ra);\n"
"    ra = .5+.5*ra;\n"
"    float dd;\n"
"    dbox(y.xy, size, dd);\n"
"    \n"
"    stroke(dv, .05, dv);\n"
"    //dv *= 15.;\n"
"    dd = mix(dd, -dv, clamp((iTime-70.)/5., 0., 1.));\n"
"    d.x = mix(dd, length(y.xy)-.5*min(size.x,size.y), clamp((iTime-40.)/5., 0.,1.));\n"
"    d.x = mix(d.x, dd, clamp((iTime-60.)/5., 0.,1.));\n"
"    \n"
"    zextrude(x.z, -d.x,mix(0.,.25*ra,clamp((iTime-25.)/5., 0.,1.)), d.x);\n"
"    d.y = 1.;\n"
"    \n"
"    // Add guard objects for debugging\n"
"    float dr = .05;\n"
"    y = mod(x,dr)-.5*dr;\n"
"    float guard = -length(max(abs(y)-vec3(.5*dr*c.xx, .6),0.));\n"
"    guard = abs(guard)+dr*.1;\n"
"    d.x = min(d.x, guard);\n"
"}\n"
"\n"
"void normal(in vec3 x, out vec3 n)\n"
"{\n"
"    const float dx = 5.e-2;\n"
"    vec2 s, na;\n"
"    \n"
"    scene(x,s);\n"
"    scene(x+dx*c.xyy, na);\n"
"    n.x = na.x;\n"
"    scene(x+dx*c.yxy, na);\n"
"    n.y = na.x;\n"
"    scene(x+dx*c.yyx, na);\n"
"    n.z = na.x;\n"
"    n = normalize(n-s.x);\n"
"}\n"
"\n"
"void colorize(in vec2 uv, out vec3 col)\n"
"{\n"
"    vec2 origin = .5*vec2(cos(iTime),sin(iTime)),\n"
"        x = mod(offset + uv, 2.*size-per_stone_offset)-size-.5*per_stone_offset,\n"
"        dx,\n"
"        xind = (uv - x) / (size+.5*per_stone_offset);\n"
"    vec2 vi;\n"
"    float dv;\n"
"        dvoronoi(uv.xy/size*.5, dv, vi);\n"
"        xind = mix(xind, vi, clamp((iTime-70.)/5., 0., 1.));\n"
"    lfnoise(xind+.1, dx.x);\n"
"    lfnoise(xind+.12, dx.y);\n"
"    \n"
"    vec4 sdf = c.xyyy;\n"
"    \n"
"    // Add background glow effect entry\n"
"    {\n"
"        float scale;\n"
"        vec2 da;\n"
"        mfnoise(uv-.4*iTime*c.xy, 14., 144., .45, da.x);\n"
"        mfnoise(uv-.1*iTime*c.xy, 14., 144., .45, da.y);\n"
"        lfnoise(14.*uv-4.*iTime*c.xy -da, scale);\n"
"\n"
"        scale *= mix(0., 1., clamp(iTime/5.,0.,1.));\n"
"                float dv;\n"
"        \n"
"\n"
"        dbox(x, size, sdf.x);\n"
"        sdf.x = -sdf.x;\n"
"        vec3 ca;\n"
"        color(clamp(-.8+1.9*scale,0.,1.),ca);\n"
"        sdf.gba = mix(ca, ca.gbr, clamp((iTime-10.)/5., 0., 1.));\n"
"\n"
"        vec4 sda, sdb;\n"
"        lfnoise(xind-iTime, scale);\n"
"        dbox(x, size, sda.x);\n"
"        sda.x = mix(sda.x, dv, clamp((iTime-70.)/5., 0., 1.));\n"
"        color(.5+.5*sin(20.*2.*pi*sda.x/max(size.x,size.y)), ca);\n"
"        sda.gba = mix(ca, ca.gbr, clamp((iTime-10.)/5., 0., 1.));\n"
"        add(sdf, sda, sda);\n"
"        \n"
"        sdf = mix(sdf, sda, clamp((iTime-15.)/5.*step(scale,0.), 0., 1.));\n"
"        \n"
"        sda.x = sdf.x;\n"
"        sda.gba = mix(sdf.gba, sdf.agb, dx.x);\n"
"        sdf = mix(sdf, sda, clamp((iTime-20.)/5.*step(scale,0.), 0., 1.));\n"
"        \n"
"        //sda.x = sdf.x;\n"
"        //sda.gba = mix(sdf.agb, sdf.gab, dx.x);\n"
"        //sdf = mix(sdf, sda, clamp((iTime-25.)/5., 0., 1.)*step(scale,0.));\n"
"    }    \n"
"    col = sdf.gba*step(sdf.x,0.);\n"
"    \n"
"    mat3 RR;\n"
"    vec3 rrt;\n"
"    lfnoise(xind + iTime*c.xx, rrt.x);\n"
"    lfnoise(xind + 1.1*iTime*c.xx, rrt.y);\n"
"    lfnoise(xind + 1.2*iTime*c.xx, rrt.z);\n"
"    rot(.4*rrt-.3*vec3(1.3,1.41,1.66)*iTime, RR);\n"
"    col = abs(RR *col);\n"
"}\n"
"\n"
"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n"
"{\n"
"    a = iResolution.x/iResolution.y;\n"
"    vec2 uv = fragCoord/iResolution.yy-0.5*vec2(a, 1.0);\n"
"    vec3 col = c.yyy;\n"
"    \n"
"    vec2 dx;\n"
"    lfnoise(uv+.1-iTime*c.xy, dx.x);\n"
"    lfnoise(uv+.12-iTime*c.yx, dx.y);\n"
"    uv += mix(c.yy,.1*dx, clamp((iTime-45.)/5.,0.,1.));\n"
"    \n"
"    size *= mix(1., .5, clamp((iTime-30.)/5.,0.,1.));\n"
"    float la;\n"
"    lfnoise(c.xx+.5*iTime, la);\n"
"    size += size*mix(0., .5*la, clamp((iTime-110.)/5.,0.,1.));\n"
"    \n"
"    colorize(uv, col);\n"
"    if(iTime > 25.) // Raymarch blocks\n"
"    {\n"
"        vec3 o = c.yyx+mix(c.yyy,-1.*c.yxy,clamp((iTime-50.)/5.,0.,1.)), dir = normalize(vec3(uv,0.)-o), y;\n"
"        float da = (.25-o.z)/dir.z;\n"
"        vec2 s;\n"
"        int N = 100, i;\n"
"        for(i=0; i<N; ++i)\n"
"        {\n"
"            y = o + da * dir;\n"
"            scene(y, s);\n"
"            if(s.x < 1.e-3) break;\n"
"            //if(y.z < 0.) break;\n"
"            da += s.x;\n"
"        }\n"
"        if(i < N)\n"
"        {\n"
"            vec3 n, l = normalize(y+c.yyx);\n"
"            normal(y, n);\n"
"            vec3 ci;\n"
"            colorize(y.xy, ci);\n"
"            col = mix(col, ci, clamp((iTime-25.)/5.,0.,1.));\n"
"            ci = .3*c.xxx\n"
"                + .3*c.yyx*abs(dot(l,n))\n"
"                + .3*c.xyx*pow(abs(dot(reflect(-l,n),dir)),3.);\n"
"            col = mix(col, .2*c.yyx, clamp(y.z*.5,0.,1.));\n"
"            mat3 RR;\n"
"            vec3 rrt;\n"
"            vec2 x = mod(offset + uv, 2.*size-per_stone_offset)-size-.5*per_stone_offset,\n"
"                xind = (uv - x) / (size+.5*per_stone_offset);\n"
"            vec2 vi;\n"
"            float dv;\n"
"            dvoronoi(y.xy/size*.5, dv, vi);\n"
"            stroke(dv, .1, dv);\n"
"            ci = mix(ci, .2*ci, step(dv,0.)*clamp((iTime-75.)/5.,0.,1.));\n"
"            xind = mix(xind, vi, clamp((iTime-70.)/5., 0., 1.));\n"
"            lfnoise(xind + iTime*c.xx, rrt.x);\n"
"            lfnoise(xind + 1.1*iTime*c.xx, rrt.y);\n"
"            lfnoise(xind + 1.2*iTime*c.xx, rrt.z);\n"
"            rot(.4*rrt-.3*vec3(1.3,1.41,1.66)*iTime, RR);\n"
"            col += abs(RR *ci);\n"
"        }\n"
"    }\n"
"    \n"
"    \n"
"    // 1: Show pattern only in stone borders\n"
"    // 2: Show party lights on stones\n"
"    // 3: Show rays that make party lights\n"
"    // 4: Move stones onto each other\n"
"    // 5: Make stones 3D and bounce\n"
"    // 6: Add fractal stuff\n"
"    \n"
"    vec3 ddd;\n"
"    rand(uv-iTime*c.xx, ddd.x);\n"
"    rand(uv-iTime*c.xx, ddd.y);\n"
"    rand(uv-iTime*c.xx, ddd.z);\n"
"    col -=.1*ddd;\n"
"    \n"
"    col = clamp(col, 0.,1.);\n"
"    \n"
"    fragColor = vec4(col,1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    mainImage(gl_FragColor, gl_FragCoord.xy);\n"
"}\n"
"\n"
;
#endif
