/* Generated with shader-compressor by NR4/Team210. */
#ifndef SHAPES_H
#define SHAPES_H
const char * shapes_frag =
"/* Pajazzo Shapes Visuals\n"
"* Copyright (C) 2019  Alexander Kraus <nr4@z10.info>\n"
"* \n"
"* This program is free software: you can redistribute it and/or modify\n"
"* it under the terms of the GNU General Public License as published by\n"
"* the Free Software Foundation, either version 3 of the License, or\n"
"* (at your option) any later version.\n"
"* \n"
"* This program is distributed in the hope that it will be useful,\n"
"* but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"* GNU General Public License for more details.\n"
"* \n"
"* You should have received a copy of the GNU General Public License\n"
"* along with this program.  If not, see <http://www.gnu.org/licenses/>.\n"
"*/\n"
"\n"
"#version 130\n"
"\n"
"uniform float iTime;\n"
"uniform vec2 iResolution;\n"
"\n"
"// Global constants\n"
"const float pi = acos(-1.);\n"
"const vec3 c = vec3(1.0, 0.0, -1.0);\n"
"float a = 1.0;\n"
"\n"
"// Hash function\n"
"void rand(in vec2 x, out float num)\n"
"{\n"
"    x += 400.;\n"
"    num = fract(sin(dot(sign(x)*abs(x) ,vec2(12.9898,78.233)))*43758.5453);\n"
"}\n"
"\n"
"// 3D hash function\n"
"void rand3(in vec3 x, out vec3 num)\n"
"{\n"
"    rand(x.x*c.xx, num.x);\n"
"    rand(x.y*c.xx, num.y);\n"
"    rand(x.z*c.xx, num.z);\n"
"}\n"
"\n"
"// Arbitrary-frequency 2D noise\n"
"void lfnoise(in vec2 t, out float num)\n"
"{\n"
"    vec2 i = floor(t);\n"
"    t = fract(t);\n"
"    //t = ((6.*t-15.)*t+10.)*t*t*t;  // TODO: add this for slower perlin noise\n"
"    t = smoothstep(c.yy, c.xx, t); // TODO: add this for faster value noise\n"
"    vec2 v1, v2;\n"
"    rand(i, v1.x);\n"
"    rand(i+c.xy, v1.y);\n"
"    rand(i+c.yx, v2.x);\n"
"    rand(i+c.xx, v2.y);\n"
"    v1 = c.zz+2.*mix(v1, v2, t.y);\n"
"    num = mix(v1.x, v1.y, t.x);\n"
"}\n"
"\n"
"// Multi-frequency 2D noise\n"
"void mfnoise(in vec2 x, in float fmin, in float fmax, in float alpha, out float num)\n"
"{\n"
"    num = 0.;\n"
"    float a = 1., nf = 0., buf;\n"
"    for(float f = fmin; f<fmax; f = f*2.)\n"
"    {\n"
"        lfnoise(f*x, buf);\n"
"        num += a*buf;\n"
"        a *= alpha;\n"
"        nf += 1.;\n"
"    }\n"
"    num *= (1.-alpha)/(1.-pow(alpha, nf));\n"
"}\n"
"\n"
"void rot(in vec3 p, out mat3 rot)\n"
"{\n"
"    rot = mat3(c.xyyy, cos(p.x), sin(p.x), 0., -sin(p.x), cos(p.x))\n"
"        *mat3(cos(p.y), 0., -sin(p.y), c.yxy, sin(p.y), 0., cos(p.y))\n"
"        *mat3(cos(p.z), -sin(p.z), 0., sin(p.z), cos(p.z), c.yyyx);\n"
"}\n"
"\n"
"// 2D box\n"
"void dbox(in vec2 p, in vec2 b, out float dst)\n"
"{\n"
"  	vec2 d = abs(p) - b;\n"
"  	dst = length(max(d,0.0)) + min(max(d.x,d.y),0.0); \n"
"}\n"
"\n"
"// 2D circle\n"
"void dcircle(in vec2 x, in float r, out float dst)\n"
"{\n"
"    dst = length(x)-r;\n"
"}\n"
"\n"
"// Stroke\n"
"void stroke(in float d0, in float s, out float d)\n"
"{\n"
"    d = abs(d0)-s;\n"
"}\n"
"\n"
"// Extrusion\n"
"void zextrude(in float z, in float d2d, in float h, out float d)\n"
"{\n"
"    vec2 w = vec2(-d2d, abs(z)-0.5*h);\n"
"    d = length(max(w,0.0));\n"
"}\n"
"\n"
"// Add sdfs to scene\n"
"void add(in vec4 old, in vec4 new, out vec4 result)\n"
"{\n"
"    result = mix(old, new, step(new.x,0.));\n"
"}\n"
"\n"
"// Mix appropriate marble colors.\n"
"void color(in float scale, out vec3 col)\n"
"{\n"
"    const int N = 13;\n"
"    const vec3 colors[N] = vec3[N](\n"
"        c.yyy,\n"
"        vec3(0.15,0.14,0.12),\n"
"        vec3(0.38,0.16,0.16),\n"
"        vec3(0.42,0.20,0.19),\n"
"        vec3(0.60,0.14,0.16),\n"
"        vec3(0.70,0.11,0.15),\n"
"        vec3(0.89,0.11,0.10),\n"
"        vec3(0.89,0.27,0.03),\n"
"        vec3(0.92,0.39,0.14),\n"
"        vec3(0.91,0.47,0.15),\n"
"        vec3(0.92,0.57,0.14),\n"
"        vec3(0.90,0.63,0.12),\n"
"        vec3(0.92,0.72,0.14)\n"
"    );\n"
"	float index = floor(scale*float(N)), \n"
"        remainder = scale*float(N)-index;\n"
"    col = mix(colors[int(index)],colors[int(index)+1], remainder);\n"
"}\n"
"\n"
"// Distance to regular voronoi\n"
"void dvoronoi(in vec2 x, out float d, out vec2 ind)\n"
"{\n"
"    vec2 y = floor(x);\n"
"   	float ret = 1.;\n"
"    \n"
"    //find closest control point. (\"In which cell am I?\")\n"
"    vec2 pf=c.yy, p;\n"
"    float df=10.;\n"
"    \n"
"    for(int i=-1; i<=1; i+=1)\n"
"        for(int j=-1; j<=1; j+=1)\n"
"        {\n"
"            p = y + vec2(float(i), float(j));\n"
"            float pa;\n"
"            rand(p, pa);\n"
"            p += pa;\n"
"            \n"
"            d = length(x-p);\n"
"            \n"
"            if(d < df)\n"
"            {\n"
"                df = d;\n"
"                pf = p;\n"
"            }\n"
"        }\n"
"    \n"
"    //compute voronoi distance: minimum distance to any edge\n"
"    for(int i=-1; i<=1; i+=1)\n"
"        for(int j=-1; j<=1; j+=1)\n"
"        {\n"
"            p = y + vec2(float(i), float(j));\n"
"            float pa;\n"
"            rand(p, pa);\n"
"            p += pa;\n"
"            \n"
"            vec2 o = p - pf;\n"
"            d = length(.5*o-dot(x-pf, o)/dot(o,o)*o);\n"
"            ret = min(ret, d);\n"
"        }\n"
"    \n"
"    d = ret;\n"
"    ind = pf;\n"
"}\n"
"\n"
"void dbreak(in vec3 x, out float dst, out vec3 ind)\n"
"{\n"
"    vec3 y = floor(x);\n"
"   	float ret = 10.;\n"
"    \n"
"    //find closest control point. (\"In which cell am I?\")\n"
"    vec3 pf=c.yyy, p;\n"
"    float df=100., d;\n"
"    \n"
"    p = y ;\n"
"                vec3 dp;\n"
"                rand3(p,dp);\n"
"                p += dp;\n"
"\n"
"                d = length(x-p);\n"
"    df = d;\n"
"    pf = p;\n"
"\n"
"    \n"
"    //compute voronoi distance: minimum distance to any edge\n"
"    for(int i=-1; i<=1; i+=1)\n"
"        for(int j=-1; j<=1; j+=1)\n"
"            for(int k=-1; k<=1; k+=1)\n"
"            {\n"
"                p = y + vec3(float(i), float(j), float(k));\n"
"                vec3 dp;\n"
"                rand3(p,dp);\n"
"                p += dp;\n"
"\n"
"                vec3 o = p - pf;\n"
"                d = abs(.5-dot(x-pf, o)/length(o));\n"
"                ret = min(ret, d);\n"
"            }\n"
"    dst = ret;\n"
"    ind = pf;\n"
"}\n"
"\n"
"vec3 ind;\n"
"void scene(in vec3 x, out vec2 sdf)\n"
"{\n"
"    mat3 RR;\n"
"    rot(.5*x, RR);\n"
"    x = mix(x, RR*x, clamp((iTime-15.)/5.,0.,1.));\n"
"    \n"
"    float iNBeats, iScale;\n"
"    lfnoise(c.xx-iTime, iNBeats);\n"
"    lfnoise(c.xx-.3*iTime-3.4, iScale);\n"
"    iNBeats *= .1;\n"
"    mat3 rm;\n"
"    rot(.05*vec3(1.,2.,3.)*iTime+iNBeats, rm);\n"
"    x = rm*x;\n"
"    float size = mix(.4,.4+.3*iScale, clamp((iTime-10.)/5.,0.,1.));\n"
"    vec3 y = mod(x, size)-.5*size;\n"
"    \n"
"    vec2 flet = vec2(atan(y.y,y.x),acos(y.z/length(y)));\n"
"    float sdr;\n"
"    mfnoise(flet-iTime, 7.e1,7.e3, .45, sdr);\n"
"    sdr = mix(0.,sdr, clamp((iTime-30.)/5.,0.,1.));\n"
"    \n"
"    size -= clamp(.4*sdr*clamp(iScale,0.,1.),-.05,.05);\n"
"    \n"
"    float vn;\n"
"    lfnoise(x.xy-2.-1.*iTime, vn);\n"
"    vec4 v = (length(y)-.3*size)*c.xxxx, w;\n"
"    float dv;\n"
"    dbox(y.xy,.3*size*c.xx,dv);\n"
"    zextrude(y.z,-dv,.4*size,dv);\n"
"    v.x = mix(v.x, dv,.5+.5*iScale);\n"
"    dbreak(2.*x-(.2+.1*iScale)*vn, w.x, w.gba);\n"
"    ind = v.gba+.1*w.gba;\n"
"    float dd, de;\n"
"    stroke(.4*w.x*size,5.e-3+1.e-3*iScale, dd);\n"
"    stroke(v.x,1.e-1*size, de);\n"
"    float d = max(-dd, de);\n"
"    d = max(-length(x)+1., d);\n"
"    stroke(d,.001, d);\n"
"    sdf = vec2(mix(de, d, (.9+iScale*.1)*clamp((iTime-5.)/5.,0.,1.)), 1.);\n"
"}\n"
"\n"
"void normal(in vec3 x, out vec3 n)\n"
"{\n"
"    const float dx = 5.e-2;\n"
"    vec2 s, na;\n"
"    \n"
"    scene(x,s);\n"
"    scene(x+dx*c.xyy, na);\n"
"    n.x = na.x;\n"
"    scene(x+dx*c.yxy, na);\n"
"    n.y = na.x;\n"
"    scene(x+dx*c.yyx, na);\n"
"    n.z = na.x;\n"
"    n = normalize(n-s.x);\n"
"}\n"
"\n"
"void stdcolor(in vec2 x, out vec3 col)\n"
"{\n"
"	col = 0.5 + 0.5*cos(iTime+x.xyx+vec3(0,2,4));\n"
"}\n"
"\n"
"void colorize(in vec2 x, out vec3 col)\n"
"{\n"
"    stdcolor(x,col);\n"
"}\n"
"\n"
"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n"
"{\n"
"    a = iResolution.x/iResolution.y;\n"
"    vec2 uv = fragCoord/iResolution.yy-0.5*vec2(a, 1.0);\n"
"    vec3 col = c.yyy;\n"
"    \n"
"    vec3 o = c.yyx+mix(c.yyy,-1.*c.yxy,clamp((iTime-50.)/5.,0.,1.)), dir = normalize(vec3(uv,0.)-o), y;\n"
"        float da = (.25-o.z)/dir.z;\n"
"        vec2 s;\n"
"        int N = 200, i;\n"
"        for(i=0; i<N; ++i)\n"
"        {\n"
"            y = o + da * dir;\n"
"            scene(y, s);\n"
"            if(s.x < 1.e-4) break;\n"
"            //if(y.z < 0.) break;\n"
"            da += s.x;\n"
"        }\n"
"        if(i < N)\n"
"        {\n"
"            float ra;\n"
"            lfnoise(c.xx-iTime, ra);\n"
"            vec3 n, l = normalize(c.yyx+mix(c.yyy, y, .5+.5*ra));\n"
"            normal(y, n);\n"
"            \n"
"            vec2 size = 5.*vec2(.3,.1);\n"
"            mat3 RR;\n"
"            vec2 vi;\n"
"            float dv;\n"
"        	dvoronoi((y.xy+y.yz+y.zx)/size*.5, dv, vi);\n"
"            stroke(dv, .01/max(size.x,size.y), dv);\n"
"            vec2 xind = ind.xy+ind.yz+ind.zx;\n"
"            vec3 rrt;\n"
"            lfnoise(xind + iTime*c.xx, rrt.x);\n"
"            lfnoise(xind + 1.1*iTime*c.xx, rrt.y);\n"
"            lfnoise(xind + 1.2*iTime*c.xx, rrt.z);\n"
"            rot(.4*rrt-.3*vec3(1.3,1.41,1.66)*iTime, RR);\n"
"            \n"
"            vec3 ci;\n"
"            colorize(y.xy, ci);\n"
"           \n"
"            ci += .1*ci\n"
"                 - 1.3*ci*abs(dot(l,n))\n"
"                 + 1.9*ci*pow(abs(dot(reflect(-l,n),dir)),3.);\n"
"            col = .5*ci;\n"
"            \n"
"            ci = mix(ci, .2*ci, step(dv,0.)*clamp((iTime-75.)/5.,0.,1.));\n"
"        	xind = mix(xind, vi, clamp((iTime-70.)/5., 0., 1.));\n"
"            \n"
"            \n"
"            col += abs(RR *ci);\n"
"            \n"
"            col = mix(col, 2.*col, step(length(rrt),.3));\n"
"            \n"
"            col *= .5;\n"
"            \n"
"            //col = mix(col, ci, clamp(tanh(1.e-1*da),0.,1.));\n"
"        }\n"
"    \n"
"    vec3 ddd;\n"
"    rand(uv-iTime*c.xx, ddd.x);\n"
"    rand(uv-iTime*c.xx, ddd.y);\n"
"    rand(uv-iTime*c.xx, ddd.z);\n"
"    col -=.1*ddd;\n"
"    \n"
"    col = clamp(col, 0., 1.);\n"
"    \n"
"    col = mix(c.yyy, col, clamp(iTime/5.,0.,1.));\n"
"    \n"
"    fragColor = vec4(col,1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    mainImage(gl_FragColor, gl_FragCoord.xy);\n"
"}\n"
"\n"
;
#endif
